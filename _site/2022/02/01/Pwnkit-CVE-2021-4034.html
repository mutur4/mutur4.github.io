<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Pwnkit: Linux Priviledge Escalation (CVE-2021-4034) | BinaryChunk’s Blog</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Pwnkit: Linux Priviledge Escalation (CVE-2021-4034)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This was a Linux Priviledge Escalation vulnerability in polkit’s pkexec that affected almost every Linux distro running the vulnerable version(s). This post covers the RCA of the vulnerability and how this was weaponized for a Local Priviledge Escalation attack." />
<meta property="og:description" content="This was a Linux Priviledge Escalation vulnerability in polkit’s pkexec that affected almost every Linux distro running the vulnerable version(s). This post covers the RCA of the vulnerability and how this was weaponized for a Local Priviledge Escalation attack." />
<link rel="canonical" href="http://0.0.0.0:4000/2022/02/01/Pwnkit-CVE-2021-4034.html" />
<meta property="og:url" content="http://0.0.0.0:4000/2022/02/01/Pwnkit-CVE-2021-4034.html" />
<meta property="og:site_name" content="BinaryChunk’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-02-01T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Pwnkit: Linux Priviledge Escalation (CVE-2021-4034)" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-02-01T00:00:00+00:00","datePublished":"2022-02-01T00:00:00+00:00","description":"This was a Linux Priviledge Escalation vulnerability in polkit’s pkexec that affected almost every Linux distro running the vulnerable version(s). This post covers the RCA of the vulnerability and how this was weaponized for a Local Priviledge Escalation attack.","headline":"Pwnkit: Linux Priviledge Escalation (CVE-2021-4034)","mainEntityOfPage":{"@type":"WebPage","@id":"http://0.0.0.0:4000/2022/02/01/Pwnkit-CVE-2021-4034.html"},"url":"http://0.0.0.0:4000/2022/02/01/Pwnkit-CVE-2021-4034.html"}</script>
<!-- End Jekyll SEO tag -->
<link id="main-stylesheet" rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://0.0.0.0:4000/feed.xml" title="BinaryChunk&apos;s Blog" />

<link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg" type="image/svg+xml">
<style>
@font-face {
  font-family: 'Open Sans';
  src: url('//fonts.gstatic.com/s/opensans/v44/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0B4kaVIGxA.woff2')
       format('woff2');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
  font-stretch: 100%;
}

body {
  font-family: 'Open Sans', sans-serif;
  font-size: 11pt;
}
</style>
</head>
<body><header class="site-header">

  <div class="wrapper">
    <a class="site-title" rel="author" href="/">BinaryChunk&#39;s Blog</a>
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon"></span>
        </label>

        <div class="nav-items">
  <a class="nav-item" href="/ctfs/">CTFs</a>
</div>

      </nav>
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Pwnkit: Linux Priviledge Escalation (CVE-2021-4034)</h1>
    <div class="post-meta">
      <time class="dt-published" datetime="2022-02-01T00:00:00+00:00" itemprop="datePublished">
        Feb 1, 2022
      </time>
    </div>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>This was a <strong>Linux Priviledge Escalation</strong> vulnerability in polkit’s pkexec that affected almost every Linux distro running the vulnerable version(s). This post covers the RCA of the vulnerability and how this was weaponized for a Local Priviledge Escalation attack.</p>

<p><strong><em>What is an OOB vulneraility?</em></strong></p>

<p>An out-of-bounds write <strong><em>(OOBW)</em></strong> vulnerability is when a process or a software
writes data past the end or before the beginning of the allocated buffer in memory.
An out-of-bounds read vulnerability <strong><em>(OOBR)</em></strong> is when a process reads data 
from outside the bounds of an allocated buffer in memory.These vulnerabilities can therefore 
lead to <em>memory corruption</em>, <em>a system crash</em> or <em>chained for RCE</em>.We are going to see in play the 
effect of these vulnerabilities chained leading to a local privilege escalation.</p>

<p><strong><em>What is this polkit pkexec in linux?</em></strong></p>

<p>This is a tool from the <em>polkit</em> or <em>policy kit software package</em> and it 
is a common component for modern unix-based systems. It is used to control
system-wide privileges and provides an organized way for non-privileged
processes to communicate with privileged processes. It can also be used to 
execute commands with elevated privileges much like <em>sudo</em> using the command
<strong>pkexec</strong> command.</p>

<p><strong><em>According to the linux manual page</em></strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>man polkit

PolicyKit provides an authorization API intended to be used by privileged 
programs <span class="o">(</span>“MECHANISMS”<span class="o">)</span> offering service to unprivileged programs <span class="o">(</span>“CLIENTS”<span class="o">)</span> 
through some form of IPC mechanism such as D-Bus or Unix pipes.

man pkexec

pkexec allows an authorized user to execute a PROGRAM as another user and 
If that username is not specified, <span class="k">then </span>the program will be executed as 
the admin super user that is root.
</code></pre></div></div>

<h3 id="root-cause-analysis-rca">Root Cause Analysis (RCA)</h3>

<p>As started earlier the vulnerability is an out-of-bounds read and write 
vulnerability and this can be seen from the source code snippet of pkexec 
that was presented by <a href="https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034">Qualys Security Company</a> 
during their disclosure.</p>

<p>Below are source code snippets that are used to describe the vulnerability in detail.</p>

<ol>
  <li>The <em><strong>main()</strong></em> entry function that processes the command-line arguments.
<em><strong>(pkexec takes in different arguments from the command-line)</strong></em></li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
	<span class="p">....</span>
	<span class="k">for</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">guint</span><span class="p">)</span> <span class="n">argc</span><span class="p">,</span> <span class="n">n</span><span class="o">++</span><span class="p">){</span>
		<span class="c1">// do something</span>
	<span class="p">}</span>
	
	<span class="n">path</span> <span class="o">=</span> <span class="n">g_strdup</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">"/"</span><span class="p">){</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">g_find_program_in_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">argv</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>
    <p>From the above snippet and as it is in every C application, the number 
of arguments are stored in <code class="language-plaintext highlighter-rouge">argc</code> variable and the actual arguments passed stored in the pointer 
array <code class="language-plaintext highlighter-rouge">char *argv[]</code>. Therefore when we pass no arguments to the <code class="language-plaintext highlighter-rouge">/usr/bin/pkexec</code> the value
of <code class="language-plaintext highlighter-rouge">argc</code> will be <code class="language-plaintext highlighter-rouge">1</code> <em><strong>(this is the calling process’s name)</strong></em> which is also the value in <strong>argv</strong> followed by a <strong>null</strong> value to terminate the array.</p>
  </li>
  <li>
    <p>This doesn’t make sense at all we need <code class="language-plaintext highlighter-rouge">argv</code> to be NULL:(, its still not vulnerable to OOB, well remember we can 
initiate any process with the <code class="language-plaintext highlighter-rouge">execve()</code> syscall and control args passed to the process. What if we pass a
<code class="language-plaintext highlighter-rouge">NULL</code> value to to <code class="language-plaintext highlighter-rouge">execve()</code> as follows:</p>

    <p><code class="language-plaintext highlighter-rouge">execve(/usr/bin/pkexec, NULL, char **envp)</code></p>
  </li>
</ul>

<blockquote>
  <p>The value of <code class="language-plaintext highlighter-rouge">argc</code> will now be <code class="language-plaintext highlighter-rouge">0</code> and the value of <code class="language-plaintext highlighter-rouge">char *argv[]</code> will be <code class="language-plaintext highlighter-rouge">NULL</code>, terminating
the array.</p>
</blockquote>

<ul>
  <li>As from the code snippet above, the following will be our values during execution.
    <ol>
      <li><em>The <code class="language-plaintext highlighter-rouge">for</code> loop initializes <code class="language-plaintext highlighter-rouge">int n</code> to <code class="language-plaintext highlighter-rouge">1</code>.</em></li>
      <li><em>The pointer <code class="language-plaintext highlighter-rouge">path</code> points to a <code class="language-plaintext highlighter-rouge">malloced()</code> address that is <code class="language-plaintext highlighter-rouge">argv[n]</code>, since the
  value of n == 1, argv[1] reads passsed our terminated array leading to an OOBR.</em></li>
      <li><em>The pointer <code class="language-plaintext highlighter-rouge">(s)</code> writes into <code class="language-plaintext highlighter-rouge">argv[1]</code> again and this leads 
  to an OOB-write vulnerability.</em></li>
    </ol>
  </li>
  <li><strong>Since we did not provide any arguments when calling the process, what is 
read and written into these pointers?.</strong> When a new process is called 
with the <code class="language-plaintext highlighter-rouge">execve()</code> syscall or when you run a new process from the 
terminal with command-line arguments, the kernel copies out arguments 
and all eviroment variable strings and pointers to the end of the new 
programs stack. That is to the end of the <code class="language-plaintext highlighter-rouge">main()</code> function stack.</li>
  <li>Therefore <code class="language-plaintext highlighter-rouge">argv</code> and <code class="language-plaintext highlighter-rouge">envp</code> pointers are contagious in memory in that they 
are next to each other as shown in the image below.</li>
</ul>

<p><img src="https://www.whitesourcesoftware.com/wp-content/media/2022/01/Screen-Shot-2022-01-27-at-7.59.19-1024x131.png" alt="image" /></p>

<ul>
  <li>
    <p>This means that when we pass no arguments to <code class="language-plaintext highlighter-rouge">pkexec</code>, <code class="language-plaintext highlighter-rouge">argv[1]</code> now points to 
out first enviroment variable that is set. Let us assume the following
scenarion:</p>

    <ol>
      <li><em>We add an environment variable called *<strong>FOO</strong>* by passing it to <code class="language-plaintext highlighter-rouge">execve()</code>.</em></li>
      <li><em>When calling <code class="language-plaintext highlighter-rouge">pkexec</code> with not command-line arguments as above, the code snippet
  will allocate <code class="language-plaintext highlighter-rouge">argv[1]</code> that is now *<strong>FOO</strong>* dynamically
  on the heap using <code class="language-plaintext highlighter-rouge">g_strdup()</code> and the address returned to the <code class="language-plaintext highlighter-rouge">(path)</code> pointer.</em></li>
      <li><em>It will then check if <code class="language-plaintext highlighter-rouge">path[0]</code> begins with <code class="language-plaintext highlighter-rouge">/</code> to determine if its an absolute path or not
  which in this case it doesn’t .</em></li>
      <li><em>Since *<strong>FOO</strong>* does not contain <code class="language-plaintext highlighter-rouge">/</code> it will execute <code class="language-plaintext highlighter-rouge">g_find_program_in_path()</code>
  and the value returned to <code class="language-plaintext highlighter-rouge">s</code> will the absolute path of <code class="language-plaintext highlighter-rouge">value</code> and this will 
  overwrite <code class="language-plaintext highlighter-rouge">argv[1]</code> which is now <code class="language-plaintext highlighter-rouge">envp[0]</code> (our environment variable) OOBW.</em></li>
    </ol>
  </li>
</ul>

<h3 id="exploitation">Exploitation</h3>

<p>How can this be exploited to gain root? According to the <strong>Qualys Security team</strong>, 
Since we control <strong>envp[0]</strong>, that is an environment variable using the OOBW 
vulnerability, we can write anything to <code class="language-plaintext highlighter-rouge">argv[1]</code> <em>(i.e envp[0])</em>. Therefore we need to 
look at some of the dangerous enviroment variables that we can exploit.</p>

<p><em><strong>(Note that after the out-of-bounds write above, the process clears out its enviroment
variables.)</strong></em></p>

<p><strong>LD_PRELOAD</strong></p>

<p>This is an enviroment variable that specifies the first shared library to load. We can 
therefore use the OOB-write to write this into our env variables but unfortuanetly, 
(ld.so) clears these types of variables out when running suid processes and 
before calling the main() function during execution.</p>

<p><strong>GCONV_PATH</strong></p>

<p>This is an enviroment variable somewhat similar to <em>LD_LIBARY_PATH</em> in functionality 
and this is part of GLib that is the GNOME Library. GLib is a library that is build 
on top of the C standard library and provides functions like error logging,authentication
and PATH lookups.</p>

<p>Since certain functions return messages to users, encoding
and decoding to and fro different formats must be considered and this 
is where GCONV_PATH comes into play.</p>

<blockquote>
  <p>When a process encounters e.g “CHARSET=UTF-8” enviroment variable, GLib 
loads $GCONV_PATH/gconv-modules or when this variable is not set the lookup 
is done from (“/usr/lib/gconv/gconv-modules”). This is a file that contains 
something like “BS_4730// UTF-8 ISO646 2” and this is used to define a module located at
“ISO646.so” that will allow “BS_4730” to be re-encoded as “UTF-8”. (this is 
just a simple example).</p>
</blockquote>

<blockquote>
  <p>When we control the <code class="language-plaintext highlighter-rouge">GCONV_PATH</code>, we can therefore cause this 
<code class="language-plaintext highlighter-rouge">SUID</code> process to run with full root privilleges by loading a shared library file that we
control in the <code class="language-plaintext highlighter-rouge">.so</code> file.</p>
</blockquote>

<h3 id="proof-of-concept-poc">Proof Of Concept (POC)</h3>

<p>Below I have provided a snippet of my POC and the full code can 
be found at my github page <a href="https://github.com/mutur4/Hacking-Scripts/tree/main/CVE-2021-4034">pwnkit.c</a> 
there are also other different POC payloads out there with the same functionality so 
be sure to check them out.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pkexec_envp</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"tmp"</span><span class="p">,</span> <span class="s">"CHARSET=xxx"</span><span class="p">,</span> <span class="s">"PATH=GCONV_PATH=."</span><span class="p">};</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pkexec_args</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">};</span>
	
	<span class="n">mkdir</span><span class="p">(</span><span class="s">"GCONV_PATH=."</span><span class="p">,</span> <span class="mo">0755</span><span class="p">);</span>
	<span class="n">open</span><span class="p">(</span><span class="s">"GCONV_PATH=./tmp"</span><span class="p">,</span> <span class="n">O_CREAT</span><span class="p">,</span> <span class="mo">0755</span><span class="p">);</span>
	<span class="n">mkdir</span><span class="p">(</span><span class="s">"tmp"</span><span class="p">,</span> <span class="mo">07555</span><span class="p">);</span>
	<span class="n">open</span><span class="p">(</span><span class="s">"tmp/gconv-modules"</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="p">,</span> <span class="mo">0755</span><span class="p">);</span>

	<span class="n">execve</span><span class="p">(</span><span class="s">"/usr/bin/pkexec"</span><span class="p">,</span> <span class="n">pkexec_args</span><span class="p">,</span> <span class="n">pkexec_envp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>The above snippet works in the following way</strong>:</p>

<ol>
  <li>
    <p>Since we provided no arguments when calling <em><strong>pkexec</strong></em> via the <code class="language-plaintext highlighter-rouge">execve()</code> syscall, 
<code class="language-plaintext highlighter-rouge">argv[1]</code> now becomes whatever we loaded in our enviroment variable that is <em><strong>tmp</strong></em>.</p>
  </li>
  <li>
    <p>Since <em><strong>tmp</strong></em> does not start with <code class="language-plaintext highlighter-rouge">/</code>, the process will look for its absolute
path and will check from the paths provided by the <code class="language-plaintext highlighter-rouge">PATH</code> enviroment variable.</p>
  </li>
  <li>
    <p>Since <em><strong>PATH</strong></em> variable contains our spoofed directory <code class="language-plaintext highlighter-rouge">GCONV_PATH=.</code> the 
value that will be returned by <code class="language-plaintext highlighter-rouge">g_find_program_in_path()</code> will be <code class="language-plaintext highlighter-rouge">GCONV_PATH=./tmp</code> 
as the absolute path.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">GCONV_PATH=./tmp</code> is a valid environment variable therefore using the 
oob-write we have an arbitrary write into <code class="language-plaintext highlighter-rouge">envp[0] = argv[1] = "GCONV_PATH=./tmp"</code>, since we also 
included a <code class="language-plaintext highlighter-rouge">CHARSET=xxx</code> , GLib now comes into play and looks for <code class="language-plaintext highlighter-rouge">GCONV_PATH</code> 
from the enviroment variables that contains <code class="language-plaintext highlighter-rouge">./tmp</code> as its value.</p>
  </li>
  <li>It will then go to out <code class="language-plaintext highlighter-rouge">./tmp</code> directory to look for <code class="language-plaintext highlighter-rouge">gconv-modules</code> and based on the contents, it will load a library from “./tmp” that we control and 
when its loaded this will lead to our privilege escalation.</li>
  <li>Basically the attack is based on the introduction of an insecure environment variable via the OOBW.</li>
</ol>

<h4 id="mitigations">Mitigations</h4>

<ol>
  <li>Update pkexec to the latest version.</li>
  <li>Remove the SUID bit in the executable.</li>
</ol>

<h3 id="references">References</h3>

<ul>
  <li>[1] https://www.whitesourcesoftware.com/resources/blog/polkit-pkexec-vulnerability-cve-2021-4034/</li>
  <li>[2] https://www.openwall.com/lists/oss-security/2022/01/25/11</li>
</ul>


  </div>

  <a class="u-url" href="/2022/02/01/Pwnkit-CVE-2021-4034.html" hidden></a>
</article>

      </div>
    </main><link id="fa-stylesheet" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css">

<footer class="site-footer h-card">
  <data class="u-url" value="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
      </div>
      <div class="footer-col">
        <p></p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li>
    <a rel="me" href="https://x.com/BinaryChunk" target="_blank" title="BinaryChunk on X">
      <span class="grey fa-brands fa-x-twitter fa-lg"></span>
    </a>
  </li><li>
    <a rel="me" href="https://github.com/mutur4" target="_blank" title="BinaryChunk on Github">
      <span class="grey fa-brands fa-github fa-lg"></span>
    </a>
  </li>
</ul>
</div>

  </div>

</footer>

</body>

</html>
